<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <title>Line Graph</title>
        <script src="libraries/raphael.js">
        </script>
        <script src="libraries/jquery-2.0.0.min.js">
        </script>
        <style>
            
            *, body {
                margin: 0;
                padding: 0;
            };
            * {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id='graphic'>
        </div>
        <script>
            
			
			
			///////////////////////////////////////////////////////////////////////////////////////
			// How tine stamps work...
			//var myDate = new Date();
			//var milliseconds = new Date().getTime();
            //var myMonth = (myDate.getMonth() + 1);
            //var myYear = (myDate.getFullYear());
			//var myDay = myDate.getUTCDate();
			//alert( myDay + ',' + myMonth + ',' + myYear);
			//alert( milliseconds + " " + new Date(myYear,myMonth,myDay).getTime());
			///////////////////////////////////////////////////////////////////////////////////////
			
			
			
            // work out spaces on y axis
            function findNiceRoundStep(delta, preferedStep){
                var log10, n, p, p10, digit;
                log10 = Math.log(10.0);
                function powOf10(n){
                    return Math.floor(Math.log(n) / log10);
                }
                n = delta / preferedStep;
                p = powOf10(n);
                p10 = Math.pow(10, p);
                digit = n / p10;
                if (digit < 1.5) {
                    digit = 1;
                }
                else 
                    if (digit < 3.5) {
                        digit = 2;
                    }
                    else 
                        if (digit < 7.5) {
                            digit = 5;
                        }
                        else {
                            p += 1;
                            p10 = Math.pow(10, p);
                            digit = 1;
                        }
                return digit * p10;
            }
			
            
            function getNumberView(startValue, numberValue, endValue){
            
                var divideBy, reternValue, regex, negativeNumber = false, endAbbreviation = "", i, devider = "1", codes;
                
                
                
                // verifying arguments
                startValue = startValue || "";
                numberValue = numberValue || 0;
                endValue = endValue || "";
                if (typeof numberValue !== "number") {
                    console.log("\nWARNING: you may get an unexpected display string returned from function 'getNumberView' because the second argument should be a number type, you are passing '" + numberValue + "' which is a " + typeof numberValue + " type");
                    if (isNaN(numberValue)) {
                        console.log("\nERROR: in function 'getNumberView' you are passing in " + numberValue + "\nand because of this the function can't make your second argument into a number which is needed to return you a correct display string\n");
                        startValue = "";
                        numberValue = 0;
                        endValue = "";
                    }
                }
                
                
                codes = [{
                    zeros: 0,
                    name: "",
                    abbreviation: ""
                }, {
                    zeros: 3,
                    name: "thousand",
                    abbreviation: "K"
                }, {
                    zeros: 6,
                    name: "million",
                    abbreviation: "MM"
                }, {
                    zeros: 9,
                    name: "billion",
                    abbreviation: "Bn"
                }, {
                    zeros: 12,
                    name: "trillion",
                    abbreviation: "Tn"
                }, {
                    zeros: 15,
                    name: "quadrillion",
                    abbreviation: "Qdn"
                }, {
                    zeros: 18,
                    name: "quintillion",
                    abbreviation: "Qtn"
                }, {
                    zeros: 21,
                    name: "sextillion",
                    abbreviation: "Stn"
                }];
                
                reternValue = Math.abs(numberValue);
                
                if (reternValue !== numberValue) {
                    negativeNumber = true;
                }
                
                reternValue = Math.ceil(reternValue);
                reternValue = reternValue.toString();
                endAbbreviation = Math.floor(Number(reternValue.length) / 3);
                
                for (i = 0; i < codes[Math.floor(Number(reternValue.length - 1) / 3)].zeros; i += 1) {
                    devider += "0";
                }
                
                reternValue = Number(numberValue) / Number(devider);
                reternValue = Math.abs(reternValue);
                
                if (reternValue >= 100 && endAbbreviation > 0) {
                    endAbbreviation -= 1;
                }
                endAbbreviation = codes[endAbbreviation].abbreviation;
                
                // get first 8 letters
                regex = /^[\s\S]{0,8}/;
                reternValue = regex.exec(reternValue).toString();
                
                reternValue = Number(reternValue);
                
                divideBy = 100;
                
                if (reternValue >= 10) {
                    divideBy = 10;
                }
                if (reternValue >= 100) {
                    divideBy = 1;
                }
                
                reternValue = Number(reternValue) * divideBy;
                
                reternValue = Math.round(reternValue);
                
                reternValue = reternValue / divideBy;
                
                if (reternValue === 0) {
                    negativeNumber = false;
                }
                if (reternValue != 0) {
					reternValue = (startValue + reternValue + endValue + endAbbreviation).toString();
				}
				
                if (negativeNumber) {
                    reternValue = "-" + reternValue;
                }
                
                return reternValue;
            }
			
			
			var area,points, minYdummyData,maxYdummyData;
			
            function randomNumber(from, to){
                return Math.floor(Math.random() * (to - from + 1) + from);
            }
			
			points = randomNumber(10, 300);
			area = randomNumber(0, 1);
			minYdummyData = randomNumber(-50000000, 50000000);
			maxYdummyData =  minYdummyData + (randomNumber(-50000000, 50000000));
			
            //make a data set
            var data = [];
            var dates = [];
			var years = 1970;
            for (var i = 0; i < points; i++) {
                data.push(randomNumber(minYdummyData, maxYdummyData));
				dates.push(randomNumber(1, 28) + "/" + randomNumber(1, 12) + "/" + years);
				years += randomNumber(1, 3);
            }
			
			/*
            for (var i = 0; i < 5; i++) {
				var date_ = (dates[i]).split("/");
				alert( date_ + " " + new Date(date_[2],date_[1] - 1,date_[0]));
            }		
			*/
            
			var pageHeight = $(window).height();
			var pageWidth= $(window).width();
			
			
            
            var canvas = Raphael("graphic", pageWidth , pageHeight );
			
			var margin = pageWidth / 10;
			
			var chartX = margin;
			var chartY = margin;
			var chartWidth = pageWidth - margin - margin;
			var chartHeight = pageHeight - margin - margin;
			
			// background
			canvas.path("M" + margin + "," + margin + "l" + chartWidth + ",0l0,"  + chartHeight + "l-" + chartWidth + ",0z"  ).attr({'stroke-width':"0","fill":"#ededed"});
			

			var widthMultiplier = 0;
			var heightMultiplier = 0;
			
			
			var maxDataPoint = data[0];
			var minDataPoint = data[0];
			
			
            for (var i = 0; i < data.length; i++) {
                if(maxDataPoint < data[i]){
					maxDataPoint = data[i];
				}
                if(minDataPoint > data[i]){
					minDataPoint = data[i];
				}				
            }			
			
			//alert( maxDataPoint + " " + minDataPoint);
			
			
			
			var yScope = 0;
			
			var basePoint = margin + chartHeight;
			
			
			if (maxDataPoint < -1 &&  minDataPoint < -1 ){
				
				//alert('both -' );
				yScope = maxDataPoint - minDataPoint;
				//alert(yScope);
				
				basePoint = margin;
				
			}  else if(maxDataPoint > -1 &&  minDataPoint > -1 ){
				
				//alert('both +' );
				yScope = maxDataPoint - minDataPoint;
				//alert(yScope);
				
				basePoint = margin + chartHeight;
								
			} else {
				
				//alert('one + and 1 -' );
				yScope = maxDataPoint + ( -1 * minDataPoint);
				//alert(yScope);
								
			}
			
            var ySpaces = 5;
			
            var ySpaceGaps = findNiceRoundStep(yScope, ySpaces);
			
            var yLineBottomValue = Math.floor(minDataPoint / ySpaceGaps) * ySpaceGaps;
            var yLineTopValue = yLineBottomValue;
			
			for(var i = 0 ; i < (ySpaces * 2) ; i++){
				
				if(yLineTopValue < maxDataPoint){
					yLineTopValue += ySpaceGaps;
				} else {
					break;
				}
				
			}
			
			yScope = yLineTopValue - yLineBottomValue;
			
			
			// test yScale
			console.log(yLineTopValue);
			console.log(maxDataPoint);
			console.log(ySpaceGaps);
			console.log(minDataPoint);
			console.log(yLineBottomValue);
			
			
			
			var yMultiplier = chartHeight / yScope;
			
			var xMultiplier = chartWidth / ( Number(data.length)   - 1) ;
			
            for (var i = 0; i < data.length; i++) {
                if(maxDataPoint < data[i]){
					maxDataPoint = data[i];
				}
                if(minDataPoint > data[i]){
					minDataPoint = data[i];
				}				
            }
			
			
			
			if (maxDataPoint > -1 &&  minDataPoint < -1 ){
				basePoint = margin + chartHeight -  ((yLineBottomValue * -1) * yMultiplier);
			}			
			
			
						
			
			//line
			//canvas.path("M" + margin + "," + margin + "l" + chartWidth + ","  + chartHeight  ).attr('stroke',"green");			

			//var line_ = "M" + (margin+(0 * xMultiplier)) + "," + basePoint  + "L" + (margin+(0 * xMultiplier)) + "," + ((margin + chartHeight) -((data[0] - minDataPoint) * yMultiplier));
			var path_ = "" + (margin+(0 * xMultiplier)) + "," + ((margin + chartHeight) -((data[0] - yLineBottomValue) * yMultiplier));


            for (var i = 1; i < data.length; i++) {

				path_ += "L" + (margin+(i * xMultiplier)) + "," + ((margin + chartHeight) - ((data[i] - yLineBottomValue) * yMultiplier));
				
            }
			
			var area_ = "M" + (margin+(0 * xMultiplier)) + "," + basePoint  + "L" + path_;
			
			area_ += "L" + (margin+((data.length - 1) * xMultiplier)) + "," + basePoint;
			
            
            if (area) {
                canvas.path(area_).attr({
                    'fill': "red",
                    "opacity": 0.3,
					'stroke': "none"
                });
            }
            else {
                canvas.path("M" + path_).attr('stroke', "red");
            }
			
			// draw horizontal lines
			
			
			
			// test yScale
			console.log(yLineTopValue);
			console.log(maxDataPoint);
			console.log(ySpaceGaps);
			console.log(minDataPoint);
			console.log(yLineBottomValue);			
			
			
			for(var i = 0 ; i < (ySpaces * 2) ; i++){
				
				if((yLineBottomValue + (i * ySpaceGaps) ) <= yLineTopValue){
					
					var y_ = ((margin + chartHeight) - ((i * ySpaceGaps) * yMultiplier )  ) ;

			// line
			canvas.path("M" + margin + "," + y_ + "l" + chartWidth + ",0" ).attr('stroke', "black");
			
			// test
			canvas.text(margin - 5, y_, getNumberView("£" , (yLineBottomValue + (i * ySpaceGaps) )) , "").attr("text-anchor","end");


				} else {
					break;
				}
				
			}			
			
			

			

			//alert(data[0] + " " + data[data.length - 1]);
            
            /*
            var total = 0;
            
            for (var i = 0; i < data.length; i++) {
                total += data[i];
            }
            
            var multiplier = 360 / total;
            
            
            var innerRadius = radius / 1.3;
            
            
            var startAngle = 0;
            var endAngle = multiplier * data[0];
            
            for (var i = 0; i < data.length; i++) {
            
                var path_ = segmentsPath(startAngle, endAngle, radius, radius, innerRadius, radius)
                
                canvas.path(path_);
                
                startAngle = 0 + endAngle;
                endAngle += (multiplier * data[i + 1]);
                
            }
            */
			
			
        </script>
    </body>
</html>
